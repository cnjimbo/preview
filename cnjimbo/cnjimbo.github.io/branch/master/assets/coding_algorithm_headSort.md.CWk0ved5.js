import{_ as r,o as n,c,I as l,w as d,a as t,j as e,a7 as s,D as a}from"./chunks/framework.B8_xTVbW.js";const R=JSON.parse('{"title":"堆排序","description":"","frontmatter":{"sidebar":{"title":"排序--堆排序","step":4},"isTimeLine":true,"title":"堆排序","date":"2020-08-02T00:00:00.000Z","tags":["手撕代码","算法与数据结构"],"categories":["手撕代码"]},"headers":[],"relativePath":"coding/algorithm/headSort.md","filePath":"coding/algorithm/headSort.md","lastUpdated":1670770660000}'),U={name:"coding/algorithm/headSort.md"},i=e("h1",{id:"堆排序",tabindex:"-1"},[t("堆排序 "),e("a",{class:"header-anchor",href:"#堆排序","aria-label":'Permalink to "堆排序"'},"​")],-1),J=s('<p>给你一个整数数组 nums，请你将该数组升序排列。</p><h2 id="原理" tabindex="-1">原理 <a class="header-anchor" href="#原理" aria-label="Permalink to &quot;原理&quot;">​</a></h2><blockquote><p>堆排序的思想就是先将待排序的序列建成大根堆，使得每个父节点的元素大于等于它的子节点。此时整个序列最大值即为堆顶元素，我们将其与末尾元素交换，使末尾元素为最大值，然后再调整堆顶元素使得剩下的 n-1n−1 个元素仍为大根堆，再重复执行以上操作我们即能得到一个有序的序列。</p></blockquote><h2 id="实现" tabindex="-1">实现 <a class="header-anchor" href="#实现" aria-label="Permalink to &quot;实现&quot;">​</a></h2><p>。。。未完待续</p><div style="display:none;" data-pagefind-meta="base64:JTdCJTIyc2lkZWJhciUyMiUzQSU3QiUyMnRpdGxlJTIyJTNBJTIyJUU2JThFJTkyJUU1JUJBJThGLS0lRTUlQTAlODYlRTYlOEUlOTIlRTUlQkElOEYlMjIlMkMlMjJzdGVwJTIyJTNBNCU3RCUyQyUyMmlzVGltZUxpbmUlMjIlM0F0cnVlJTJDJTIydGl0bGUlMjIlM0ElMjIlRTUlQTAlODYlRTYlOEUlOTIlRTUlQkElOEYlMjIlMkMlMjJkYXRlJTIyJTNBMTU5NjMyNjQwMDAwMCUyQyUyMnRhZ3MlMjIlM0ElNUIlMjIlRTYlODklOEIlRTYlOTIlOTUlRTQlQkIlQTMlRTclQTAlODElMjIlMkMlMjIlRTclQUUlOTclRTYlQjMlOTUlRTQlQjglOEUlRTYlOTUlQjAlRTYlOEQlQUUlRTclQkIlOTMlRTYlOUUlODQlMjIlNUQlMkMlMjJjYXRlZ29yaWVzJTIyJTNBJTVCJTIyJUU2JTg5JThCJUU2JTkyJTk1JUU0JUJCJUEzJUU3JUEwJTgxJTIyJTVEJTdE"></div>',6);function M(h,_,p,I,m,y){const o=a("company"),T=a("LeetCode");return n(),c("div",null,[i,l(o,{value:"几种常见时间复杂度比较低的排序算法之一"}),l(T,{href:"https://leetcode-cn.com/problems/sort-an-array/"},{default:d(()=>[t("912：排序树组")]),_:1}),J])}const O=r(U,[["render",M]]);export{R as __pageData,O as default};
